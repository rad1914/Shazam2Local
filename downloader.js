// @path: downloader.js
import path from'path';import{exec}from'./exec.js';import{sanitizeFilename,w,s,e,S,recordMatches,stripFileNoise}from'./utils/utils.js';import{sr,lr}from'./utils/record.js';import{O,Y,C,c as cookiesExist}from'./config.js';const UNAVAILABLE=/Video unavailable|private|not available|rate-limited/i,RATE_LIMIT=/rate[- ]limited|session has been rate-limited/i,outPath=m=>path.join(O,`${sanitizeFilename(m.finalName)}.%(ext)s`),run=cmd=>exec(cmd),searchCandidates=q=>{const b=stripFileNoise(q).trim();return[b,b.replace(/[-–—()].*$/,''),b.split(/\s+/).slice(0,6).join(' '),q].filter(Boolean)},findBySearch=async(q,client)=>{for(const sq of searchCandidates(q))for(const n of[5,10]){const cmd=`yt-dlp --dump-single-json "ytsearch${n}:${sq.replace(/"/g,'\\"')}"${client?` --extractor-args "youtube:player_client=${client}"`:''}`;try{const{stdout}=await run(cmd),{entries=[]}=JSON.parse(stdout);if(entries.length)return entries.map(e=>({id:e.id,url:`https://youtu.be/${e.id}`,title:e.title}))}catch(err){w(`Search fail "${sq}" (${n}): ${(err.stderr||err.message||'').slice(0,150)}`)}}return[]},tryYtDl=(u,m,client,useCookies=!0,sleep=!1)=>run(`yt-dlp ${Y}${useCookies&&cookiesExist()?` --cookies "${C}"`:''}${client?` --extractor-args "youtube:player_client=${client}"`:''}${sleep?' --sleep-interval 5 --max-sleep-interval 10':''} -o "${outPath(m)}" "${u}"`),download=async(m,rec,client)=>{const handleErr=async(err,url,useCookies)=>{const msg=(err.stderr||err.stdout||err.message||'').toString();if(UNAVAILABLE.test(msg)){if(RATE_LIMIT.test(msg)&&useCookies&&cookiesExist()){w(`Rate-limit detected. Retrying "${m.finalName}" without cookies...`),await tryYtDl(url,m,client,!1,!0);return!0}throw new Error(msg)}throw err};if(/^ytsearch/i.test(m.query)){const term=m.query.replace(/^ytsearch\d*:\s*/i,''),results=await findBySearch(term,client);for(const{id,url,title}of results)try{await tryYtDl(url,m,client),rec.push({id,title,artist:m.artist,...m.extraMeta}),s(`Downloaded${client?` (${client})`:''}: "${m.finalName}"`);return}catch(err){try{if(await handleErr(err,url,!0))return}catch{w(`Skip ${id} (${title})`)}}throw new Error('All search candidates failed')}try{await tryYtDl(m.query,m,client),rec.push({id:m.id,title:m.title,artist:m.artist,...m.extraMeta}),s(`Downloaded${client?` (${client})`:''}: "${m.finalName}"`)}catch(err){await handleErr(err,m.query,!0),rec.push({id:m.id,title:m.title,artist:m.artist,...m.extraMeta})}},tryDownload=async(m,rec)=>{const already=a=>recordMatches(a,m.checkKeys);try{if(already(await lr()))return w(`Skip (disk): "${m.finalName}"`),{success:!1,skipped:!0}}catch{w(`Warn: couldn't read downloaded.json`)}if(already(rec))return w(`Skip (session): "${m.finalName}"`),{success:!1,skipped:!0};for(const client of[null,'android','web'])try{if(already(await lr()))return w(`Skip (post-check): "${m.finalName}"`),{success:!1,skipped:!0};await download(m,rec,client),await sr(rec).catch(err=>w(`Write fail after "${m.finalName}": ${err.message}`));return{success:!0}}catch(err){const msg=(err.stderr||err.message||'').toString();if(UNAVAILABLE.test(msg)||client==='web')return e(`Fail "${m.finalName}": ${msg}`),{success:!1,reason:msg};w(`Retrying "${m.finalName}" via ${client??'default'} client...`)}};export const processEntries=async(entries,rec,buildMeta,label)=>{const ok=[],fail=[];let done=0,skip=0,mod=!1;for(const e of entries){const m=buildMeta(e);if(!m)continue;if(recordMatches(rec,m.checkKeys)){w(`Skip: "${m.finalName}"`),skip++;continue}const res=await tryDownload(m,rec);if(res.skipped){skip++;continue}res.success?(ok.push(m),done++,mod=!0):fail.push({...m.checkKeys,title:m.title,reason:res.reason})}if(mod)await sr(rec).catch(err=>w(`Write fail: ${err.message}`));return S(`${label} done: downloaded ${done}, skipped ${skip}`),{successful:ok,failed:fail}};
